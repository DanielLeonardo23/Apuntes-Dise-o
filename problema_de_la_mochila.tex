\section{El problema de la mochila}
El problema de la mochila es un clásico en el ámbito de la optimización combinatoria y la teoría de algoritmos. Se trata de seleccionar un subconjunto de artículos, cada uno con un peso y un valor, de manera que se maximice el valor total sin exceder la capacidad de peso permitida. Este problema es fundamental en campos como la logística, la gestión de recursos y la toma de decisiones en la ingeniería. La programación dinámica y las técnicas de aproximación ofrecen métodos eficientes para resolver este problema.

\subsection{Ejemplo 1}
Un naviero tiene un buque carguero con capacidad de hasta 500 toneladas. El carguero transporta contenedores de diferentes pesos para una determinada ruta. En la ruta actual el carguero puede transportar algunos de los siguientes contenedores:

\begin{table}[h!]
\centering
\begin{tabular}{|c|c|c|c|c|c|}
\hline
Contenedor & 1 & 2 & 3 & 4 & 5 \\
\hline
Peso en (cientos de toneladas) & 1 & 2 & 1 & 3 & 4 \\
\hline
Valor (miles de dólares) & 3 & 5 & 4 & 6 & 7 \\
\hline
\end{tabular}
\caption{Datos ejemplo 1}
\end{table}

El analista de la empresa del armador desea determinar el envío (conjunto de contenedores) que maximiza el valor de la carga transportada.

\subsubsection{Código}
\begin{lstlisting}
def algoritmo_mochila(pesos, valores, capacidad):
    n = len(pesos)  
    matriz = []
    for i in range(n + 1):
        fila = []
        for j in range(capacidad + 1):
            fila.append(0)  
        matriz.append(fila)  

    for i in range(1, n + 1):  
        for w in range(1, capacidad + 1):  
            if pesos[i - 1] <= w:  
                matriz[i][w] = max(matriz[i - 1][w], valores[i - 1] + matriz[i - 1][w - pesos[i - 1]])  
            else:
                matriz[i][w] = matriz[i - 1][w]  

    valor_maximo = matriz[n][capacidad]
    return valor_maximo

pesos = [1, 2, 1, 3, 4]  # Pesos en centenas de toneladas
valores = [3, 5, 4, 6, 7]   # Valores en miles de dolares
capacidad = 500              # Capacidad del carguero en toneladas
capacidad_ajustada = capacidad // 100  # Ajustar a centenas
valor_maximo = algoritmo_mochila(pesos, valores, capacidad_ajustada)
print("El valor maximo de la carga transportada es:", valor_maximo, "miles de dolares.")
\end{lstlisting}

\subsubsection{Resultado}
El valor maximo de la carga transportada es: 13 miles de dolares.

\subsubsection{Análisis de complejidad}

\subsection*{Detalle de Complejidad}

\textbf{1. A: Inicialización de la matriz.}

El código correspondiente es:
\begin{lstlisting}
matriz = []
for i in range(n + 1):  # O(n)
    fila = []
    for j in range(capacidad + 1):  # O(capacidad)
        fila.append(0)  # O(1)
    matriz.append(fila)  # O(1)
\end{lstlisting}

- Inicializar la matriz con ceros tiene una complejidad de \( O(n \times capacidad) \).

\textbf{2. B: Llenado de la matriz con los valores óptimos.}

El código correspondiente es:
\begin{lstlisting}
for i in range(1, n + 1):  # O(n)
    for w in range(1, capacidad + 1):  # O(capacidad)
        if pesos[i - 1] <= w:  # O(1)
            matriz[i][w] = max(matriz[i - 1][w], valores[i - 1] + matriz[i - 1][w - pesos[i - 1]])  # O(1)
        else:
            matriz[i][w] = matriz[i - 1][w]  # O(1)
\end{lstlisting}

- El llenado de la matriz para calcular los valores óptimos tiene una complejidad de \( O(n \times capacidad) \).

\textbf{3. C: Determinación del valor máximo.}

El código correspondiente es:
\begin{lstlisting}
valor_maximo = matriz[n][capacidad]  # O(1)
\end{lstlisting}

- La determinación del valor máximo es una operación constante \( O(1) \).

\subsection*{Complejidad Total}

\[
T(n, capacidad) = O(n \times capacidad)
\]

\subsection*{Variables}

\begin{itemize}
    \item \( n \) = número de artículos.
    \item \( capacidad \) = capacidad de la mochila en centenas de toneladas.
\end{itemize}

\subsection{Ejemplo 2}
Una empresa de transporte marítimo de mercancías posee un barco con una bodega cuya capacidad es de 250 cm³. Desea transportar cuatro bienes de los que se dispone su volumen y su valor monetario. En la siguiente tabla se muestra dicha información:

\begin{table}[H]
    \centering
    \begin{tabular}{cccc}
        \toprule
        \textbf{Bienes} & \textbf{Volumen (cm\(^3\)/Tm)} & & \textbf{Ingresos (\$)} \\
        \midrule
        1 & 70 & & 1250 \\
        2 & 50 & & 900 \\
        3 & 60 & & 1000 \\
        4 & 75 & & 1200 \\
        \bottomrule
    \end{tabular}
    \caption{Datos del problema de la mochila. Elaboración propia.}
    \label{tab:datos_problema}
\end{table}

Se trata de determinar los bienes que se deben transportar en la bodega de forma que el ingreso sea máximo.

\subsubsection{Código}
\begin{lstlisting}[language=Python]
def mochila(capacidad, volumenes, ingresos, n):
    # Crear una matriz para almacenar los ingresos maximos posibles
    dp = [[0 for x in range(capacidad + 1)] for x in range(n + 1)]

    # Llenar la matriz dp de manera ascendente
    for i in range(n + 1):
        for w in range(capacidad + 1):
            if i == 0 or w == 0:
                dp[i][w] = 0
            elif volumenes[i - 1] <= w:
                dp[i][w] = max(ingresos[i - 1] + dp[i - 1][w - volumenes[i - 1]], dp[i - 1][w])
            else:
                dp[i][w] = dp[i - 1][w]

    # Recuperar los elementos seleccionados
    res = dp[n][capacidad]
    w = capacidad
    bienes_seleccionados = []

    for i in range(n, 0, -1):
        if res <= 0:
            break
        if res == dp[i - 1][w]:
            continue
        else:
            bienes_seleccionados.append(i - 1)
            res -= ingresos[i - 1]
            w -= volumenes[i - 1]

    # Crear una lista que indique si cada bien se lleva (1) o no (0)
    seleccion = [0] * n
    for i in bienes_seleccionados:
        seleccion[i] = 1

    return dp[n][capacidad], bienes_seleccionados, seleccion

# Datos del problema
volumenes = [70, 50, 60, 75]
ingresos = [1250, 900, 1000, 1200]
capacidad = 250
n = len(volumenes)

# Resolver el problema
ingreso_maximo, bienes_seleccionados, seleccion = mochila(capacidad, volumenes, ingresos, n)

print(f"El ingreso maximo es: ${ingreso_maximo}")
print("Bienes seleccionados (indices):", bienes_seleccionados)
print("Seleccion de bienes (1 = seleccionado, 0 = no seleccionado):")
for i in range(n):
    print(f"Bien {i + 1}: {seleccion[i]}")
\end{lstlisting}

\subsubsection{Resultado}
El ingreso máximo que se puede trasportar en la bodega es de \$ 3450.

Los bienes seleccionados se encuentran en los índices 3, 2 y 0.

En otras palabras, se elige:
\begin{itemize}
\item El primer bien (Volumen = 70, Ingreso = \$ 1250).
\item El tercer bien (Volumen = 60, Ingreso = \$ 1200).
\item El cuarto bien (Volumen = 75, Ingreso = \$ 1200).
 \end{itemize}

\subsubsection{Análisis de complejidad}


\textbf{1. A: Inicialización de la matriz.}

El código correspondiente es:
\begin{lstlisting}
	dp = [[0 for x in range(capacidad + 1)] for x in range(n + 1)]
	# Complejidad: O(n * capacidad)
\end{lstlisting}

- La creación de esta matriz tiene \( O(n \times capacidad) \) de complejidad. 

\textbf{2. B: Llenado de la matriz "dp"}

El código correspondiente es:
\begin{lstlisting}
	for i in range(n + 1):
		for w in range(capacidad + 1):
			if i == 0 or w == 0:
				dp[i][w] = 0  # O(1)
			elif volumenes[i - 1] <= w:
				dp[i][w] = max(ingresos[i - 1] + dp[i - 1][w - volumenes[i - 1]], dp[i - 1][w])  # O(1)
			else:
				dp[i][w] = dp[i - 1][w]  # O(1)
	# Complejidad: O(n * capacidad)
\end{lstlisting}

El llenado de la matriz, el doble bucle anidado, tiene una complejidad de \( O(n \times capacidad) \).

\textbf{3. C: Recuperar los Elementos Seleccionados.}

El código correspondiente es:
\begin{lstlisting}
	res = dp[n][capacidad]  # O(1)
	w = capacidad  # O(1)
	bienes_seleccionados = []  # O(1)
	
	for i in range(n, 0, -1):
		if res <= 0:
			break  # O(1)
		if res == dp[i - 1][w]:
			continue  # O(1)
		else:
			bienes_seleccionados.append(i - 1)  # O(1)
			res -= ingresos[i - 1]  # O(1)
			w -= volumenes[i - 1]  # O(1)
	# Complejidad: O(n)
\end{lstlisting}
-Este bucle se ejecuta como maximo 'n'veces por lo que su complejidad es \( O(n) \).

\textbf{4. D: Inicialización de la Lista seleccion.}

El código correspondiente es:
\begin{lstlisting}
	seleccion = [0] * n
	# Complejidad: O(n)
\end{lstlisting}
- La inicializacion de esta lista requiere recorrer n elementos, por tal motivo la complejidad es de \( O(n) \).

\textbf{5. E: Asignación de Bienes Seleccionados a la Lista seleccion.}

El código correspondiente es:
\begin{lstlisting}
	for i in bienes_seleccionados:
		seleccion[i] = 1  # O(1)
	# Complejidad: O(n)
\end{lstlisting}
Este bucle recorre la lista \textit{bienes\_seleccionados}, lo cual puede tener en el peor de los casos como máximo \( n \) elementos. Entonces la complejidad es de \( O(n) \).

\subsection*{Complejidad Total}

Como se acaba de apreciar, el presente algoritmo tiene una complejidad de n x capacidad, lo cual supone eficiencia en funcion al dato de entrada de “capacidad”; mientras más sea esto, más complejo se vuelve.
La complejidad dominante del algoritmo es la inicialización y el llenado de la matriz dp que representaria nuestra complejidad total:

\[
T(n, capacidad) = O(n \times capacidad)
\]

\subsection*{Variables}

\begin{itemize}
	\item \( n \) = Numero de bienes disponibles.
	\item \( capacidad \) = Capacidad total de la bodega.
\end{itemize}




Como se acaba de apreciar, el presente algoritmo tiene una complejidad aproximada de O(n x K) o, equivalentemente, n x capacidad, lo cual supone eficiencia en funcion al dato de entrada de “capacidad”; mientras mas sea esto, mas complejo se vuelve.
